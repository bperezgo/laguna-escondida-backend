# Laguna Escondida Backend - Hexagonal Architecture Rules

## Architecture Overview

This project follows **Hexagonal Architecture (Ports and Adapters)** principles with a clean separation between domain logic and infrastructure concerns.

### Directory Structure

```
internal/
├── domain/          # Core business logic (use cases layer)
│   ├── ports/       # Interfaces (ports) - define contracts
│   ├── service/     # Use cases - business logic implementation
│   ├── dto/         # Data Transfer Objects - plain structs, no logic
│   └── error/       # Custom domain errors
└── platform/        # Implementation layer (adapters)
    ├── handler/     # HTTP handlers (primary adapters)
    └── postgres/    # Database implementations (secondary adapters)
        ├── migrations/
        └── repository/
```

## Dependency Rules (Critical)

### Dependency Flow (Dependency Inversion Principle)
- **Domain layer** (`internal/domain/`) MUST NOT depend on platform layer (`internal/platform/`)
- **Platform layer** (`internal/platform/`) CAN depend on domain layer
- **Domain** defines interfaces (ports), **Platform** implements them (adapters)
- Dependencies flow INWARD: Platform → Domain (never Domain → Platform)

### Import Rules
- ✅ `platform/handler` can import `domain/service`, `domain/dto`, `domain/error`
- ✅ `platform/postgres/repository` can import `domain/ports`
- ❌ `domain/service` MUST NOT import `platform/*`
- ❌ `domain/ports` MUST NOT import `platform/*`
- ❌ `domain/dto` MUST NOT import `platform/*`
- ❌ `domain/error` MUST NOT import `platform/*`

## Domain Layer Guidelines

### `domain/ports/` - Interfaces (Ports)
- Define **interfaces only** - no implementations
- Use descriptive names ending with the entity/service (e.g., `ProductRepository`, `BillService`)
- Keep interfaces focused and single-purpose (Interface Segregation Principle)
- Example structure:
  ```go
  // domain/ports/product_repository.go
  type ProductRepository interface {
      Create(ctx context.Context, product *dto.Product) error
      FindByID(ctx context.Context, id string) (*dto.Product, error)
      // ... other methods
  }
  ```

### `domain/service/` - Use Cases (Business Logic)
- Contains **all business logic** and use case implementations
- **MUST** depend on interfaces from `domain/ports/`, never concrete implementations
- Use dependency injection to receive port implementations
- Example structure:
  ```go
  // domain/service/product_service.go
  type ProductService struct {
      repo ports.ProductRepository
  }
  
  func NewProductService(repo ports.ProductRepository) *ProductService {
      return &ProductService{repo: repo}
  }
  
  func (s *ProductService) CreateProduct(ctx context.Context, req *dto.CreateProductRequest) (*dto.Product, error) {
      // Business logic here
      // Validate, transform, orchestrate
      return s.repo.Create(ctx, product)
  }
  ```

### `domain/dto/` - Data Transfer Objects
- **Plain structs only** - no methods, no business logic
- Used for data transfer between layers
- Can include validation tags (e.g., `validate`, `json`)
- Example:
  ```go
  // domain/dto/product.go
  type Product struct {
      ID          string    `json:"id"`
      Name        string    `json:"name"`
      Price       float64   `json:"price"`
      CreatedAt   time.Time `json:"created_at"`
  }
  
  type CreateProductRequest struct {
      Name  string  `json:"name" validate:"required,min=1,max=100"`
      Price float64 `json:"price" validate:"required,gt=0"`
  }
  ```

### `domain/error/` - Custom Errors
- Define domain-specific errors
- Use error wrapping for context
- Example:
  ```go
  // domain/error/product_error.go
  var (
      ErrProductNotFound = errors.New("product not found")
      ErrInvalidProduct  = errors.New("invalid product data")
  )
  ```

## Platform Layer Guidelines

### `platform/handler/` - HTTP Handlers (Primary Adapters)
- Handle HTTP requests/responses only
- **MUST** call domain services, not repositories directly
- Transform HTTP requests to DTOs and DTOs to HTTP responses
- Keep handlers thin - delegate to domain services
- Example:
  ```go
  // platform/handler/product_handler.go
  func CreateProductHandler(service *service.ProductService) http.HandlerFunc {
      return func(w http.ResponseWriter, r *http.Request) {
          var req dto.CreateProductRequest
          if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
              http.Error(w, err.Error(), http.StatusBadRequest)
              return
          }
          
          product, err := service.CreateProduct(r.Context(), &req)
          if err != nil {
              // Handle error appropriately
              return
          }
          
          json.NewEncoder(w).Encode(product)
      }
  }
  ```

### `platform/postgres/repository/` - Database Implementations (Secondary Adapters)
- Implement interfaces from `domain/ports/`
- Handle all database-specific logic (SQL queries, transactions, etc.)
- Convert between database models and domain DTOs
- Example:
  ```go
  // platform/postgres/repository/product_repository.go
  type ProductRepository struct {
      db *sql.DB
  }
  
  func NewProductRepository(db *sql.DB) ports.ProductRepository {
      return &ProductRepository{db: db}
  }
  
  func (r *ProductRepository) Create(ctx context.Context, product *dto.Product) error {
      // SQL implementation
  }
  ```

## General Guidelines

### Naming Conventions
- **Interfaces**: Use descriptive names without `Interface` suffix (e.g., `ProductRepository`, not `ProductRepositoryInterface`)
- **Implementations**: Use descriptive names (e.g., `ProductRepository` struct that implements `ports.ProductRepository`)
- **Services**: End with `Service` (e.g., `ProductService`)
- **Handlers**: End with `Handler` (e.g., `CreateProductHandler`)
- **DTOs**: Use descriptive names (e.g., `Product`, `CreateProductRequest`, `UpdateProductRequest`)

### Context Usage
- **Always** pass `context.Context` as the first parameter in:
  - Repository methods
  - Service methods
  - Handler methods (extract from request)
- Use context for cancellation, timeouts, and request-scoped values

### Error Handling
- Use domain errors from `domain/error/` for business logic errors
- Use standard library errors for infrastructure errors
- Wrap errors with context using `fmt.Errorf` with `%w` verb
- Return errors to handlers, don't log in domain layer (log in handlers/adapters)

### Dependency Injection
- Use constructor functions (e.g., `NewProductService`, `NewProductRepository`)
- Wire dependencies in `cmd/main.go` or a separate wiring file
- Pass interfaces, not concrete types

### Testing

#### Unit Testing Strategy
- **Every service MUST have comprehensive unit tests** - Create `*_service_test.go` files alongside each service file
- **Every new use case MUST include tests** - When implementing a new use case, create corresponding test cases
- **Test coverage target: 90%+** for service methods
- Use **testify** libraries: `assert`, `mock`, `require`, `suite`
- Mock all repository dependencies using `testify/mock`
- Test all code paths: success cases, error cases, edge cases, and calculation validations

#### Test Structure
- Use table-driven tests for multiple similar scenarios
- Organize tests by category: Success Cases, Error Cases, Calculation Validation, Edge Cases
- Create reusable test helpers: `createTestContext()`, `createTestProduct()`, `createTestService()`, etc.
- Use mock structs implementing port interfaces (e.g., `MockProductRepository`, `MockOpenBillRepository`)

#### Test Modification Protocol
- **ALWAYS ask before modifying existing unit tests** when changing service implementations
- When adding new functionality to an existing service:
  1. Check if existing tests cover the new behavior
  2. If modifying behavior, ask: "Is it OK to update the existing unit tests for [ServiceName] to reflect the new behavior?"
  3. Only proceed with test modifications after user confirmation
- When fixing bugs, update tests to cover the bug fix

#### Test File Naming
- Test files: `{service_name}_test.go` (e.g., `order_service_test.go`)
- Test functions: `Test{ServiceName}_{MethodName}_{Scenario}` (e.g., `TestCreateOrder_EmptyOrder`)

#### Example Test Structure
```go
// Mock repositories
type MockProductRepository struct {
    mock.Mock
}
func (m *MockProductRepository) FindByIDs(ctx context.Context, ids []string) ([]*dto.Product, error) {
    args := m.Called(ctx, ids)
    return args.Get(0).([]*dto.Product), args.Error(1)
}

// Test helpers
func createTestProduct(...) *dto.Product { ... }
func createTestService(...) *OrderService { ... }

// Success Cases
func TestCreateOrder_EmptyOrder(t *testing.T) { ... }
func TestCreateOrder_SingleProduct(t *testing.T) { ... }

// Error Cases
func TestCreateOrder_ProductNotFound(t *testing.T) { ... }

// Calculation Validation
func TestCreateOrder_TaxCalculations(t *testing.T) { ... }
```

#### Integration Testing
- Platform layer tests may require integration tests with actual database
- Use separate test files or build tags for integration tests

## Example Flow

1. **HTTP Request** → `platform/handler/ProductHandler`
2. **Handler** → Validates request, converts to DTO
3. **Handler** → Calls `domain/service/ProductService.CreateProduct()`
4. **Service** → Contains business logic, validates domain rules
5. **Service** → Calls `ports.ProductRepository` (interface)
6. **Repository** → `platform/postgres/repository/ProductRepository` (implementation)
7. **Repository** → Executes SQL, returns DTO
8. **Service** → Returns DTO to handler
9. **Handler** → Converts DTO to HTTP response

## Code Generation & Tooling

- Use `go generate` for code generation if needed
- Keep migrations in `platform/postgres/migrations/`
- Use SQL migrations for database schema changes

## When Adding New Features

1. **Define DTOs** in `domain/dto/`
2. **Define port interface** in `domain/ports/`
3. **Implement use case** in `domain/service/`
4. **Create unit tests** in `domain/service/{service_name}_test.go` (MANDATORY)
5. **Implement repository** in `platform/postgres/repository/`
6. **Create handler** in `platform/handler/`
7. **Wire dependencies** in `cmd/main.go`

**Note**: When modifying existing services, always ask before updating existing unit tests.

Remember: **Domain is the heart, Platform is the shell**. Keep domain pure and independent.

